<?php

/**
 * @file
 * Contains derhasi\Composer\Installers\NestedInstaller
 */

namespace derhasi\Composer\Installers;

use Composer\Installers\Installer;
use Composer\Package\PackageInterface;
use Composer\Repository\InstalledRepositoryInterface;

/**
 * Class NestedInstaller.
 */
class NestedInstaller extends Installer {

  /**
   * {@inheritDoc}
   */
  public function install(InstalledRepositoryInterface $repo, PackageInterface $package) {

    $backups = $this->backupSubpaths($repo, $package);

    try {
      parent::install($repo, $package);
    }
    catch (\Exception $e) {
      // In the case of an exception we should restore backups first,
      // before the script fails.
      $this->restoreSubpaths($repo, $package, $backups);
      throw $e;
    }

    $this->restoreSubpaths($repo, $package, $backups);
  }

  /**
   * {@inheritDoc}
   */
  public function update(InstalledRepositoryInterface $repo, PackageInterface $initial, PackageInterface $target) {
    $backups = $this->backupSubpaths($repo, $target);

    try {
      parent::update($repo, $initial, $target); // TODO: Change the autogenerated stub
    }
    catch (\Exception $e) {
      // In the case of an exception we should restore backups first,
      // before the script fails.
      $this->restoreSubpaths($repo, $target, $backups);
      throw $e;
    }

    $this->restoreSubpaths($repo, $target, $backups);
  }

  /**
   * {@inheritDoc}
   */
  public function uninstall(InstalledRepositoryInterface $repo, PackageInterface $package) {

    $backups = $this->backupSubpaths($repo, $package);

    try {
      parent::uninstall($repo, $package);
    }
    catch (\Exception $e) {
      // In the case of an exception we should restore backups first,
      // before the script fails.
      $this->restoreSubpaths($repo, $package, $backups);
      throw $e;
    }

    $this->restoreSubpaths($repo, $package, $backups);
  }


  /**
   * Backs up the configured subpaths.
   *
   * @param InstalledRepositoryInterface $repo
   * @param PackageInterface $package
   *
   * @return array
   *   Array of backed up path information:
   *   - key: original path
   *   - value: backup location
   */
  protected function backupSubpaths(InstalledRepositoryInterface $repo, PackageInterface $package) {
    $extra = $this->composer->getPackage()->getExtra();

    // if we got no subdir configuration, we do not have anythign to backup.
    if (empty($extra['installer-preserve-subpaths'])) {
      return array();
    }

    $subpaths = $extra['installer-preserve-subpaths'];
    $installPath = $this->getInstallPath($package);
    $installPathNormalized = $this->filesystem->normalizePath($installPath);

    // Check if any subpath maybe affected by installation of this package.
    $backup_paths = array();
    foreach ($subpaths as $path) {
      $normalizedPath = $this->filesystem->normalizePath($path);
      if (file_exists($path) && strpos($normalizedPath, $installPathNormalized) === 0) {
        $backup_paths[] = $normalizedPath;
      }
    }

    // If no paths need to be backed up, we simply proceed.
    if (empty($backup_paths)) {
      return array();
    }

    // Otherwise we back those up to a cache subdirectory.
    $cache_dir = $this->composer->getConfig()->get('cache-dir');
    $unique = $package->getUniqueName() . ' ' . time();
    $cache_root = $this->filesystem->normalizePath($cache_dir . '/installer-preserve-subpaths/' . sha1($unique));
    $this->filesystem->ensureDirectoryExists($cache_root);

    $return = array();
    foreach ($backup_paths as $original) {
      $backup_location = $cache_root . '/' . sha1($original);
      $this->filesystem->rename($original, $backup_location);
      $return[$original] = $backup_location;
    }
    return $return;
  }

  /**
   * Restore previously backed up subpaths.
   *
   * @param InstalledRepositoryInterface $repo
   * @param PackageInterface $package
   * @param array $backups
   *   Array of backed up path information:
   *   - key: original path
   *   - value: backup location
   *
   * @see Installer::backupSubpaths()
   */
  protected function restoreSubpaths(InstalledRepositoryInterface $repo, PackageInterface $package, $backups) {
    if (empty($backups)) {
      return;
    }

    foreach ($backups as $original => $backup_location) {

      // Remove any code that was placed by the package at the place of
      // the original path.
      if (file_exists($original)) {
        if (is_dir($original)) {
          $this->filesystem->emptyDirectory($original, false);
          $this->filesystem->removeDirectory($original);
        }
        else {
          $this->filesystem->remove($original);
        }

        $this->io->write(sprintf('<comment>Content of package %s was overwritten with preserved path %s!</comment>', $package->getUniqueName(), $original), true);
      }

      $this->filesystem->ensureDirectoryExists(dirname($original));
      $this->filesystem->rename($backup_location, $original);

      if ($this->filesystem->isDirEmpty(dirname($backup_location))) {
        $this->filesystem->removeDirectory(dirname($backup_location));
      }
    }
  }

}